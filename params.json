{"name":"LiteDB","tagline":"LiteDB - A .NET NoSQL Document Store in a single data file","body":"# LiteDB - A .NET NoSQL Document Store in a single data file\r\n\r\nLiteDB is a small, fast and lightweight NoSQL embedded database. \r\n\r\n- Serverless NoSQL Document Store\r\n- Simple API similar to MongoDB\r\n- 100% C# code for .NET 3.5 in a single DLL - install from NuGet: `Install-Package LiteDB`\r\n- Transaction control - ACID\r\n- Recovery in writing failure (journal mode)\r\n- Store POCO classes or BsonDocument\r\n- Store files and stream data (like GridFS in MongoDB)\r\n- Single data file storage (like SQLite)\r\n- Index document fields for fast search (up to 16 indexes per collection)\r\n- Inital LINQ support for queries\r\n- Shell command line - [try this online version](http://litedb.azurewebsites.net/)\r\n- Open source and free for everyone - including commercial use\r\n\r\n## Try online\r\n\r\n[Try LiteDB Web Shell](http://litedb.azurewebsites.net/). For security reasons, in online version not all commands are available. Try offline version for full features tests.\r\n\r\n## How install\r\n\r\nLiteDB is a serverless database, so there is no install. Just copy LiteDB.dll to your Bin folder and add as Reference. If you prefer, you can use NuGet package: `Install-Package LiteDB`. If you are running in a web environment, be sure that IIS user has write permission on data folder.\r\n\r\n## How to use\r\n\r\nA quick example for store and search documents:\r\n\r\n```C#\r\n// Open data file (or create if not exits)\r\nusing(var db = new LiteEngine(@\"C:\\Temp\\MyData.db\"))\r\n{\r\n    // Get a collection (or create, if not exits)\r\n    var col = db.GetCollection<Customer>(\"customers\");\r\n    \r\n    var customer = new Customer { Id = 1, Name = \"John Doe\" };\r\n\r\n\t// Insert new customer document\r\n\tcol.Insert(customer);\r\n    \r\n    // Update a document inside a collection\r\n    customer.Name = \"Joana Doe\";\r\n    \r\n    col.Update(customer);\r\n    \r\n\t// Index document using a document property\r\n\tcol.EnsureIndex(x => x.Name);\r\n\r\n    // Simple Linq support\r\n\tvar result = col.Find(x => x.Name.StartsWith(\"Jo\"));\r\n}\r\n```\r\n\r\n## Where to use?\r\n\r\n- Desktop/local applications\r\n- Small web applications\r\n- One database **per account/user** data store\r\n- Few concurrency write users operations\r\n\r\n# LiteDB Guide\r\n\r\nLiteDB is a NoSQL Database based on a document store: a simple  very simple API similar to MongoDB C# official driver.\r\n\r\n## Documents\r\n\r\nLiteDB works with documents to store and retrive data inside data file. Your document definition can be a POCO class or BsonDocument class. In both case, LiteDB will convert your document in a BSON format to store inside disk.\r\n\r\nBSON is a Binary JSON, a serialization for store data objects as binary array. In BSON, we have more data types than JSON. LiteDB supports `Null`, `Array`, `Object`, `Byte`, `ByteArray`, `Char`, `Boolean`, `String`, `Short`, `Int`, `Long`, `UShort`, `UInt`, `ULong`, `Float`, `Double`, `Decimal`, `DateTime`, `Guid`.\r\n\r\nIn LiteDB, documents are limited in 256Kb.\r\n\r\n### Documents using POCO class\r\n\r\nPOCO class are simple C# classes using only `get/set` properties. It's the best way to create a strong typed documents. Your class must have a `Id` property to LiteDB identify your document. You can use `Id` named property or decorate a property with `[BsonId]` attribute. Your `Id` value must be a unique and not null. Also, `Id` data type must be a valid indexed data type. See Index section.\r\n\r\n``` C#\r\n// A poco entity, must have Id\r\npublic class Customer\r\n{\r\n\tpublic Guid Id { get; set; }\r\n\tpublic string Name { get; set; }\r\n\tpublic List<Phone> Phones { get; set; }\r\n}\r\n\r\n// It's not a entity, don't need Id\r\npublic class Phone\r\n{\r\n    public int Code { get; set; }\r\n    public string Number { get; set; }\r\n    public PhoneType Type { get; set; }\r\n}\r\n\r\npublic enum PhoneType { Mobile, Landline }\r\n``` \r\n\r\n- Do not use complex data types (like `DataSet`, `DataTable`)\r\n- Do not use disposable objects (like `Stream`, `Graphics`)\r\n- Enums will be converted in strings when serialized\r\n\r\n### Documents using BsonDocument\r\n\r\nBsonDocument is a special class that maps any document with a internal `Dictionary<string, object>`. Is very useful to read a unknown document type or use as a generic document.\r\n\r\n```C#\r\n// Create a BsonDocument for Customer with phones\r\nvar doc = new BsonDocument();\r\ndoc.Id = Guid.NewGuid();\r\ndoc[\"Name\"] = \"John Doe\";\r\ndoc[\"Phones\"] = new BsonArray();\r\ndoc[\"Phones\"].Add(new BsonObject());\r\ndoc[\"Phones\"][0][\"Code\"] = 55;\r\ndoc[\"Phones\"][0][\"Number\"] = \"(51) 8000-1234\";\r\ndoc[\"Phones\"][0][\"Type\"] = \"Mobile\";\r\n```\r\n\r\nWith BsonDocument you can create any complex document schema.\r\n\r\n## Collections - the store\r\n\r\nLiteDB organize documents in stores (called in LiteDB as collections). Each collection has a unique name and contains documents with same schema/type. You can get a strong typed collection or a generic BsonDocument collections, using `GetCollection` from `LiteEngine` instance.\r\n\r\n```C#\r\nvar db = new LiteEngine(stringConnection);\r\n\r\n// Get a strong typed collection\r\nvar customers = db.GetCollection<Customer>(\"Customers\");\r\n\r\n// Get a BsonDocument collection \r\nvar customers = db.GetCollection(\"Customers\");\r\n```\r\n\r\nCollection contains all method to manipulate documents:\r\n\r\n* `Insert` - Insert a new document\r\n* `FindById` , `FindOne` or `Find` - Find a document using Query object or LINQ expression. At this point, only simple LINQ are supported - attribute on left, value on right side.\r\n* `Update` - Update a document\r\n* `Delete` - Delete a document id or using a query\r\n* `Include` - Use include to populate properties based on others collections\r\n* `EnsureIndex` - Create a index if not exists. All queries must have a index.\r\n\r\n## Query\r\n\r\nIn LiteDB, queries use indexes to search documents. You can use `Query` helper or Linq expressions.\r\n\r\n```C#\r\nvar customers = db.GetCollection<Customer>(\"customers\");\r\n\r\n// Create a new index (if not exists)\r\ncustomers.EnsureIndex(\"Name\");\r\n\r\n// Query documents using 'Name' index\r\nvar results = customers.Find(Query.StartsWith(\"Name\", \"John\"));\r\n\r\n// Or using Linq\r\nvar results = customers.Find(x > x.Name.StartsWith(\"John\"));\r\n\r\n// Return document by ID (PK index)\r\nvar customer = customers.FindById(1);\r\n\r\n// Count only documents where ID >= 2\r\nvar count = customers.Count(Query.GTE(\"_id\", 2));\r\n\r\n// All query results returns an IEnumerable<T>, so you can use Linq after too\r\nvar linq = customers.Find(x => x.Salary > 500 && x.Salary < 1000) // indexed query \r\n    .Where(x => x.LastName.Length > 5 && x.Age > 22) // in memory query\r\n    .Select(x => new { x.Name, x.Salary })\r\n    .OrderBy(x => x.Name);\r\n```\r\n\r\n`Query` class supports `All`, `Equals`, `Not`, `GreaterThan`, `LessThan`, `Between`, `In`, `StartsWtih` and `OR`.\r\nAll operations need an index to be executed.\r\n\r\n## Transactions\r\n\r\nLiteDB is atomic in transaction level. All write operations are executed inside a transaction. If you do not use `BeginTrans` and `Commit` methods, transaction are implicit for each operation.\r\n\r\nFor simplicity, LiteDB do not support concurrency transactions. LiteDB locks your datafile to guarantee that 2 users are not changing data at same time. So, do not use big transactions operations or keep a open transaction without commit or rollback.\r\n\r\n### Fail tolerance - Journaling\r\n\r\nAfter commit method called, LiteDB store all dirty pages to disk. This operations is a fail torelance. Before write direct to disk, LiteDB create a temp file (called journal file) to store all dirty pages. If there is any error during write data file, journaling save a redo log file with database dirty pages, to recovery your datafile when datafile open again. \r\n\r\n```C#\r\nusing(var db = new LiteEngine(dbpath))\r\n{\r\n    db.BeginTrans();\r\n    \r\n    // Do many write operations (insert, updates, deletes),\r\n    //   but if throw any error during this operations, a Rollback() will be called automatic\r\n    \r\n    db.Commit();\r\n}\r\n```\r\n\r\n## Storing Files\r\n\r\nSametimes we need store files in database. For this, LiteDB has a special `Files` collection to store files without document size limit (file limit is 2Gb per file). It's works like MongoDB `GridFS`.\r\n\r\n```C#\r\n// Storing a file stream inside database\r\ndb.Files.Upload(\"my_key.png\", stream);\r\n\r\n// Get file reference using file id\r\nvar file = db.Files.FindById(\"my_key.png\");\r\n\r\n// Find all files using StartsWith\r\nvar files = db.Files.Find(\"my_\");\r\n\r\n// Get file stream\r\nvar stream = file.OpenRead();\r\n\r\n// Write file stream in a external stream\r\ndb.Files.Download(\"my_key.png\", stream);\r\n```\r\n\r\n## Connection String\r\n\r\nConnection string options to initialize LiteEngine class:\r\n\r\n- **Filename**: Path for datafile. You can use only path as connection string (required)\r\n- **Timeout**: timeout for wait for unlock datafile (default: 00:01:00)\r\n- **Journal**: Enabled journal mode - recovery support (default: true)\r\n\r\n## Dependency\r\n\r\nLiteDB has no external dependency, but use [fastBinaryJson](http://fastbinaryjson.codeplex.com/) as BSON serializer \r\nfrom/to .NET objects. All source are included inside LiteDB source.\r\n\r\n## Roadmap\r\n\r\nCurrently, LiteDB is in testing version and are not full ready for production. Please, be careful on use.\r\n\r\nSame features/ideas for future\r\n\r\n- Compound index: one index for multiple fields\r\n- Multikey index: index for array values\r\n- Full text search\r\n","google":"UA-54329029-1","note":"Don't delete this file! It's used internally to help with page regeneration."}
# LiteDB v.2 - TODO

- BasePage.OriginalBuffer
- Revisar BsonArray.Length não faz cache
- Remover/Revisar transacao - Locks
- Implementar StreamDiskService()
- Thread Safe
- InitialSize para FileDiskService
- Remove auto-register do shell


## Cache

Para saber qual caminho seguir em relação a cache, acho que precisa fazer branchs para testar:

1) A "dev" como está: usa cache sem limites
2) Não usa cache nenhuma para leitura, apenas para dirty pages
3) Usa cache para salvar com limitador de tamanho. Vai gravando em disco conforme vai ficando dirty (grava a cada X paginas sujas)

Preciso criar uma banchmark para testar os mais diversos tipos de situação:

a) Criação de um banco grande de 1 unica coleção
b) Criação de um banco grande de 100 coleções diferentes
c) Criação de indice
d) Leitura de todos os registros
e) Leitura conforme indice (retorno poucos registros)

> Para cada teste, deve usar documento grande/complexo e documento pequeno/simples
> Avaliar tempo/consumo total de memória
> Aproveitar os testes para fazer PAGE_SIZE de 8K tb

?? Remover escrita ta header page no filedisk
?? pager.SetDirty(page) antes de alterar
?? Implementer SortDictionaryMRU
?? Implementar cache de 2 repos

## A pensar:

- Voltar UserVersion??
- Solução de Migrations (protected?)
    db.Migrations.Add(new Migration1());
- DefaultIndexOptions? Ou sem default - não cria indice automaticamente - ou full search?
- Folder root: "src", "test", "nuget"
- Encrypt datafile (EncryptDiskService : FileDiskService)

- Como implementar pro DNX
- Mapeador/Configuration estilo EF
    db.Configuration.Add(new CredorConfiguration())


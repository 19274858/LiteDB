# LiteDB v.2 - TODO

- BasePage.OriginalBuffer
- BasePage.MRU
- pager.SetDirty(page) antes de alterar

- Implementer SortDictionaryMRU
- Revisar BsonArray.Length não faz cache

- Remover/Revisar transacao - Locks
- Implementar cache de 2 repos
- Substituir BsonSerializer pela versao 2
- Remover BinaryReader/WriterExtentensions
- Implementar StreamDiskService()
- Otimizar GetChangeID() no IDiskService
- Thread Safe

## Cache

Otimizar a cache:

- Ter uma cache exclusiva para Header (só 1)
- Ter uma cache exclusiva para as Collecitons (são poucas e muito usadas)
- As demais (Indice, Data, Extend) pode ser por ordem circular
- Cache exclusiva, não circular, para paginas dirty (indice/data/extend)

## A pensar:

- Voltar user/version??
- Voltar string connection??
- A implementacaos dos multiplos IDiskService ser apenas interna??
- Sistema de Disk mais complexo (suporte a Journal/Recovery no FileDisk)
- Folder: "src", "test", "nuget"
- Como implementar pro DNX


BasePage {
	long MRU;
}

class MruCache {

	SortedDictionary<uint, BasePage> _cache;
	SortedDictionary<uint, BasePage> _dirty;
	int limit = 100;
	int rem = 10;
	
	void Add() {
		page.MRU = DateTime.Now.Tricks; // ou lock(inc)
		_dirty[page.PageID] = page;
		RemoveOlds();
	}
	
	BasePage Get(pageID) {
		var page = _cache[pageID];
		page.MRU = DateTime.Now.Ticks; // ou lock(inc)
	}
	
	void AddDirtyPage(page) {
		page.IsDirty;
		_dirty[page.PageID] = page;
	}
	
	void ClearDirty() {
		// _copy _dirty -> _cache
	}
	
	void Clear() {
		// _cache & _dirty
	}
	
	void RemoveOlds() {
		if(_cache.Count() > limit) {
			// linq retornas IDs
			_cache.remove(arrayIDs)
		}
	}

}
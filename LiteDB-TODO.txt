# LiteDB v.2 - TODO

- Revisar transação - Remover possibilidade
    - Rollback continua existindo? Ou só commit? O que fazer quando ocorre erro na transacao (journal)

- Revisar auto-id de Int32 (q usa collection)    
- Toda operação do LiteDB agora é atomica (sem transacao)    
- Queria que o IDiskService não tivesse informações sobre Journal/Recovery

- Revisar BsonArray.Length não faz cache
- Implementar StreamDiskService()
- Thread Safe
- Remove auto-register do shell
- Fazer db.Debbuger? Com opção de Verbose, opções de avaliação de timing de performance...
    db.Debugger.TextWriters = Stream();


## Cache

Para saber qual caminho seguir em relação a cache, acho que precisa fazer branchs para testar:

1) A "dev" como está: usa cache sem limites
2) Não usa cache nenhuma para leitura, apenas para dirty pages
3) Usa cache para salvar com limitador de tamanho. Vai gravando em disco conforme vai ficando dirty (grava a cada X paginas sujas)

Preciso criar uma banchmark para testar os mais diversos tipos de situação:

a) Criação de um banco grande de 1 unica coleção
b) Criação de um banco grande de 100 coleções diferentes
c) Criação de indice
d) Leitura de todos os registros
e) Leitura conforme indice (retorno poucos registros)

> Para cada teste, deve usar documento grande/complexo e documento pequeno/simples
> Avaliar tempo/consumo total de memória
> Aproveitar os testes para fazer PAGE_SIZE de 8K tb

?? Remover escrita ta header page no filedisk
?? pager.SetDirty(page) antes de alterar
?? Implementer SortDictionaryMRU
?? Implementar cache de 2 repos

## A pensar:

- Voltar UserVersion??
- Solução de Migrations (protected?)
    db.Migrations.Add(new Migration1());
- DefaultIndexOptions? Ou sem default - não cria indice automaticamente - ou full search?
- Folder root: "src", "test", "nuget"
- Encrypt datafile (EncryptDiskService : FileDiskService)

- Como implementar pro DNX
- Mapeador/Configuration estilo EF
    db.Configuration.Add(new CredorConfiguration())

